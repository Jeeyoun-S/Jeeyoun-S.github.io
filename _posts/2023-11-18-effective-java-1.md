---
title: Effective Java 2장
tags: [Java]
style: fill
color: success
description: Effective Java 2장 객체 생성과 파괴
---

1. this unordered seed list will be replaced by toc as unordered list
{:toc}

## Item 01. 생성자 대신 정적 팩터리 메서드를 고려하라
### 정적 팩터리 메서드의 장점
- 이름을 가질 수 있다
  - 생성자와 매개변수만으로는 객체의 특성을 설명 어려움
  - 정적 팩터리 메서드는 이름으로 객체의 특성 묘사 가능
- 호출될 때마다 인스턴스를 새로 생성할 필요 없다
  - 불변 클래스의 경우, 인스턴스를 만들어두거나 캐싱해 재활용 가능

> **플라이웨이트 패턴**  
> 인스턴스를 가능한 공유해서 메모리를 절약하는 패턴

- 반환 타입의 하위 타입을 반환할 수 있다
  - 반환할 객체의 클래스를 자유롭게 선택하는 유연성
- 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다
  - 반환 타입의 하위 타입이면, 어떤 클래스의 객체든 반환 가능
  - 예시 : EnumSet
- 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 부재해도 된다  

### 정적 팩터리 메서드의 단점
- public이나 protected 생성자 없이, 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다
  - 상속보다 컴포지션을 사용하도록 유도
- 정적 팩터리 메서드는 프로그래머가 찾기 어렵다
  - API 설명에 명확히 드러나지 않음
  - API 문서를 잘 작성하고 규약에 따라 메서드 이름을 작성해 보완 가능

### 정적 팩터리 메서드의 명명 방식

| 메서드 이름 | 설명 | 비고 |
|:-------------:| ------------- |
| from | 매개변수 1개, 해당 타입의 인스턴스 반환 |
| of | 매개변수 여러 개, 적합한 타입의 인스턴스 반환 (집계 메서드) |
| valueOf | from, of의 더 자세한 버전 |
| instance / getInstance | 매개변수에 명시한 인스턴스 반환 |
| create / newInstance | getInstance와 동일하지만, 매번 새로운 인스턴스 반환 |
| getType | 다른 클래스의 팩터리 메서드를 정의 (Type : 반환할 객체 타입) |
| newType | getType과 동일하지만, 매번 새로운 인스턴스 반환 |
| type | getType과 newType의 간결한 버전 |

## Item 02. 생성자에 매개변수가 많다면 빌더를 고려하라
선택적 매개변수가 많은 경우, {% include elements/highlight.html text="점층적 생성자 패턴" %}을 사용하는 경우가 많았다. 이러한 경우 단점은
- 설정하길 원치 않는 매개변수도 값을 지정해야 한다
- 매개변수 개수가 많아지면, 코드를 작성하거나 읽기 어렵다

다른 대안으로는 {% include elements/highlight.html text="자바빈즈 패턴" %}(매개변수가 없는 생성자로 객체를 만들고, Setter로 값 설정)이 있다. 이러한 경우 단점은
- 객체 하나를 만들기 위해 여러 개의 메서드를 호출한다
- 일관성이 무너진다 → 클래스를 불변으로 만들 수 없다

세 번째 대안은 {% include elements/highlight.html text="빌더 패턴" %}이다. 이 경우 장점은
- 코드를 쓰고 읽기 쉽다
- 계층적으로 설계된 클래스와 사용하기 좋다
- 가변인수 매개변수를 여러 개 사용할 수 있
- 높은 유연성을 갖는다

빌더 패턴의 단점은
- 빌더를 만들어야 한다
- 장황한 코드로 매개변수가 4개 이상일 때 값어치가 있다

## Item 03. private 생성자나 열거 타입으로 싱글턴임을 보증하라
### 싱글턴을 만드는 방식
생성자는 private으로 감추고, public static 멤버를 하나 만든다.

- public static final 필드
  ```java
  public class Elvis {
    // private 생성자는 아래에서 한 번 호출된다. 
    private static final Elvis INSTANCE = new Elvis(); 
    private Elvis() { } 
  } 
  ```
  1. API에서 싱글턴임이 명백히 드러난다
  2. 간결하다
  3. 직렬화를 위해 Serializable 외에 추가적인 구현이 필요하다

- public static 정적 팩터리 메서드
  ```java
  public class Elvis { 
    private static final Elvis INSTANCE = new Elvis(); 
    private Elvis() { };
    public static Elvis getInstance() {
      return INSTANCE; 
    };
  } 
  ```
  1. API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다
  2. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다
  3. 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다
  4. 위 3번과 동일

- 원소가 하나인 열거 타입
  ```java
  public enum Elvis { 
    INSTANCE; 
  } 
  ```
  1. 가장 간결하다
  2. 추가 구현 없이 직렬화 가능
  3. Enum 외의 클래스를 상속해야 한다면 사용할 수 없다

## Item 04. 인스턴스화를 막으려거든 private 생성자를 사용하라
추상 클래스로 만드는 것으로 인스턴스화를 막을 수 없다. 생성자를 명시하지 않으면, 컴파일러가 자동으로 기본 생성자를 만들어 주기 때문이다.
**private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.**

- 명시적 생성자가 private이니 클래스 바깥에서 접근 불가능
- private 생성자에서 에러를 던지면, 클래스 내부에서 생성자 호출도 방지
- 상속 불가능 (상위 클래스의 생성자에 접근 불가능)

## Item 05. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
많은 클래스는 하나 이상의 자원에 의존한다. 이런 클래스는 **정적 유틸리티**와 **싱글턴**으로 구현하는 경우가 흔하다. 이는 유연하지 않고 테스트가 어렵다는 단점이 있다.

> **정적 유틸리티 클래스**
> static method와 static method만 담은 클래스

예를 들어 맞춤법 검사기(SpellChecker)에서 사전(dictionary)라는 사전을 사용하면, 앞서 언급한 2가지 경우는 사전을 단 하나만 사용한다고 가정한다.
여러 사전을 사용할 수 있어야 한다면, **인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식**을 사용한다.

- 불변을 보장 → 여러 클라이언트가 의존 객체를 안전하게 공유 가능
- 생성자, 정적 팩터리, 빌더 모두에 응용 가능
- 의존성이 수천 개가 되는 프로젝트에서는 코드가 복잡해 진다

변형된 방법으로는 **생성자에 자원 팩터리를 넘겨주는 방식**이 있다.

## Item 06. 불필요한 객체 생성을 피하라
똑같은 기능의 객체를 매번 생성하기보다 **하나의 객체를 재사용하는 것을 나은 경우가 존재**한다.
아래 예시에서는 문자열이 유효한 숫자인지 확인하는 메서드가 작성돼 있다. 이 메서드의 경우, 내부에서 **Pattern 인스턴스를 만들어 사용하고 곧바로 버린다.**
```java
static boolean isRomanNumeralSlow(String s) { 
  return s.matches("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$"); 
} 
```

아래 코드는 **Pattern 인스턴스를 직접 생성해 캐싱해 두고 사용**한다. isRomanNumeral가 빈번히 사용될 경우 앞선 코드보다 성능이 개선된다.
```java
private static final Pattern ROMAN = Pattern.compile(
  "^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$"
); 
static boolean isRomanNumeralFast(String s) { 
  return ROMAN.matcher(s).matches(); 
} 
```

이 외에 불필요한 객체를 만들어 낼 필요가 없는 경우
- 의도하지 않은 오토박싱으로 많은 인스턴스 생성
- Map 인터페이스의 keySet 메서드
항상 객체를 새로 생성하는 것을 피해야 하는 것은 아니고, 아주 무겁지 않으면 객체 풀을 만들 필요가 없다. 복사가 필요한 상황에 객체를 재사용했을 때는 버그, 보안 구멍 등의 문제가 발생할 수 있으나, 불필요한 객체를 생성하는 것은 코드의 형태와 성능에만 영향을 미친다는 점을 명심해야 한다.

## Item 07. 다 쓴 객체 참조를 해제하라
객체 참조 하나를 살려두면, 가비지 컬렉터는 객체가 참조하는 모든 객체를 회수하지 못한다. 따라서 메모리 누수로 인해 잠재적으로 성능에 악영향이 있을 수 있다.
해당 참조를 다 쓰면 **null 처리하면 참조를 해제**할 수 있다. 다만, null 처리를 하는 일은 예외적인 경우여야 한다.

- 메모리를 직접 관리하는 클래스
- 캐시
- 리스너 혹은 콜백

## Item 08. finalizer와 cleaner 사용을 피하라
Java는 finalizer, cleaner 객체 소멸자를 제공한다.

- finalizer  
  예측할 수 없고 상황에 따라 위험할 수도 있어 일반적으로 불필요하다. 기본적으로 쓰지 말아야 한다.

- cleaner  
  finalizer의 대안으로 제시됐다. finalizer보다는 덜 위험하지만, 예측할 수 없고 느리고 일반적으로 불필요하다.

### finalizer와 cleaner를 사용하는 것을 피해야 하는 경우와 이유
- 상태를 영구적으로 수정하는 작업에서 사용하면 안 된다.
  - 실행 시점을 보장할 수 없다. 
  - 실행 여부를 보장할 수 없다. 
- 심각한 성능 문제를 동반한다.
  - 가비지 컬렉터의 효율을 떨어뜨린다.
- finalizer 공격에 노출돼 보안 문제를 일으킬 수 있다.
  - 생성자나 직렬화 과정에서 예외 발생 시, 악의적인 하위 클래스의 finalizer가 실행 가능해 허용되지 않은 작업이 수행된다.
  - final이 아닌 클래스는 아무것도 하지 않는 finalizer를 만들어 공격을 방어한다.

### 종료해야 할 자원을 담고 있는 경우, 대안책
- AutoCloseable 구현
  - 인스턴스를 다 쓰고 나면 close 메서드 호출

### finalizer와 cleaner의 쓰임
- close 메서드를 호출하지 않는 경우에 대한 안전망
- 네이티브 피어와 연결된 객체의 회수

## Item 09. try-finally보다는 try-with-resources를 사용하라
**try-finally**은 아래와 같은 문제가 있다.
- 자원이 2개 이상이라면 코드가 지저분하다
- 예외 처리 시, 디버깅이 어려워지는 경우가 있다

Java 7 이후부터는 **try-with-resources**를 사용할 수 있다. 자원이 AutoCloseable 인터페이스를 구현해야 한다.
- 짧고 읽기 수월하다
- 예외를 파악하기도 좋다